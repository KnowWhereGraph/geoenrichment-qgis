# -*- coding: utf-8 -*-
"""
/***************************************************************************
 kwg_geoenrichment
                                 A QGIS plugin
 KWG Geoenrichment plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Rushiraj Nenuji, University of California Santa Barbara
        email                : nenuji@nceas.ucsb.edu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QTranslator, QSettings, QCoreApplication, qVersion, QVariant
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QMenu, QInputDialog, QAbstractItemView, QLineEdit
from qgis.PyQt.QtGui import QIcon

from qgis.core import QgsFeature, QgsProject, QgsGeometry, \
    QgsCoordinateTransform, QgsCoordinateTransformContext, QgsMapLayer, \
    QgsFeatureRequest, QgsVectorLayer, QgsLayerTreeGroup, QgsRenderContext, \
    QgsCoordinateReferenceSystem, QgsWkbTypes, QgsMessageLog, Qgis, QgsFields, QgsField, QgsVectorFileWriter
from qgis.gui import QgsRubberBand

# Initialize Qt resources from file resources.py
from PyQt5.uic.properties import QtWidgets

from .resources import *
# Import the code for the dialog
from .kwg_geoenrichment_dialog import kwg_geoenrichmentDialog
from .kwg_property_geoenrichment_dialog import kwg_property_geoenrichmentDialog
from .kwg_property_merge_dialog import kwg_property_mergeDialog
from .kwg_linkedData_relationship_finder_dialog import kwg_linkedDataDialog
from .kwg_property_enrichment import kwg_property_enrichment
from .kwg_property_merge import kwg_property_merge
from .kwg_linkedData_relationship_finder import kwg_linkedData_relationship_finder
from .kwg_explore_dialog import kwg_exploreDialog
from .kwg_sparqlquery import kwg_sparqlquery
from .kwg_util import kwg_util as UTIL
from .kwg_json2field import kwg_json2field as Json2Field

# Import QDraw settings
from .drawtools import DrawPoint, DrawRect, DrawLine, DrawCircle, DrawPolygon,\
    SelectPoint, XYDialog, DMSDialog
from .qdrawsettings import QdrawSettings

from configparser import ConfigParser

import json
import os.path
import logging
import geojson
# import geopandas as gpd
# from osgeo import gdal

# import gdal
import subprocess

class kwg_geoenrichment:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'kwg_geoenrichment_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&KWG Geoenrichment')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # QDraw specific configs
        self.sb = self.iface.statusBarIface()
        self.tool = None
        self.toolname = None
        self.toolbar = self.iface.addToolBar('KWG Geoenrichment')
        self.toolbar.setObjectName('KWG Geoenrichment')
        self.bGeom = None
        self.settings = QdrawSettings()

        # Set up the config file
        conf = ConfigParser()
        self._config = conf.read('config.ini')
        self.logger = logging.getLogger()
        self.logger.setLevel(logging.DEBUG)  # or whatever
        handler = logging.FileHandler('/var/local/QGIS/kwg_geoenrichment.log', 'w', 'utf-8')  # or whatever
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(filename)s:%(funcName)s - %(message)s')  # or whatever
        handler.setFormatter(formatter)  # Pass handler as a parameter, not assign
        self.logger.addHandler(handler)

        self.sparqlQuery = kwg_sparqlquery()

        self.eventPlaceTypeDict = dict()


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('kwg_geoenrichment', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        checkable=False,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        menu=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        action.setCheckable(checkable)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if menu is not None:
            action.setMenu(menu)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        self.add_action(
            QIcon(':/plugins/kwg_geoenrichment/resources/graph_Query.png'),
            text=self.tr(u'GeoSPARQL Query'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.add_action(
            QIcon(':/plugins/kwg_geoenrichment/resources/enrich_Data.png'),
            text=self.tr(u'Property Enrichment Query'),
            callback=self.runPropertyEnrichment,
            parent=self.iface.mainWindow())

        self.add_action(
            QIcon(':/plugins/kwg_geoenrichment/resources/merge_Data.png'),
            text=self.tr(u'Property Merge Tool'),
            callback=self.runPropertyMerge,
            parent=self.iface.mainWindow())

        self.add_action(
            QIcon(':/plugins/kwg_geoenrichment/resources/merge_Data.png'),
            text=self.tr(u'Link Data Relationship Finder Tool'),
            callback=self.runRelationshipFinder,
            parent=self.iface.mainWindow())


        self.add_action(
            QIcon(':/plugins/kwg_geoenrichment/resources/graph_Query.png'),
            text=self.tr(u'KWG Explore Tool'),
            callback=self.runKWGExplore,
            parent=self.iface.mainWindow())

        # Adding menu to toolbar
        pointMenu = QMenu()
        pointMenu.addAction(
            QIcon(':/plugins/kwg_geoenrichment/resources/icon_DrawPtXY.png'),
            self.tr('XY Point drawing tool'), self.drawXYPoint)
        pointMenu.addAction(
            QIcon(':/plugins/kwg_geoenrichment/resources/icon_DrawPtDMS.png'),
            self.tr('DMS Point drawing tool'), self.drawDMSPoint)
        icon_path = ':/plugins/kwg_geoenrichment/resources/icon_DrawPt.png'
        self.add_action(
            icon_path,
            text=self.tr('Point drawing tool'),
            checkable=True,
            menu=pointMenu,
            add_to_toolbar=True,
            callback=self.drawPoint,
            parent=self.iface.mainWindow()
        )
        icon_path = ':/plugins/kwg_geoenrichment/resources/icon_DrawL.png'
        self.add_action(
            icon_path,
            text=self.tr('Line drawing tool'),
            checkable=True,
            add_to_toolbar=True,
            callback=self.drawLine,
            parent=self.iface.mainWindow()
        )
        # icon_path = ':/plugins/kwg_geoenrichment/resources/icon_DrawR.png'
        # self.add_action(
        #     icon_path,
        #     text=self.tr('Rectangle drawing tool'),
        #     checkable=True,
        #     add_to_toolbar=True,
        #     callback=self.drawRect,
        #     parent=self.iface.mainWindow()
        # )
        # icon_path = ':/plugins/kwg_geoenrichment/resources/icon_DrawC.png'
        # self.add_action(
        #     icon_path,
        #     text=self.tr('Circle drawing tool'),
        #     checkable=True,
        #     add_to_toolbar=True,
        #     callback=self.drawCircle,
        #     parent=self.iface.mainWindow()
        # )
        icon_path = ':/plugins/kwg_geoenrichment/resources/icon_DrawP.png'
        self.add_action(
            icon_path,
            text=self.tr('Polygon drawing tool'),
            checkable=True,
            add_to_toolbar=True,
            callback=self.drawPolygon,
            parent=self.iface.mainWindow()
        )
        bufferMenu = QMenu()
        polygonBufferAction = QAction(
            QIcon(':/plugins/kwg_geoenrichment/resources/icon_DrawTP.png'),
            self.tr('Polygon buffer drawing tool on the selected layer'),
            bufferMenu)
        polygonBufferAction.triggered.connect(self.drawPolygonBuffer)
        bufferMenu.addAction(polygonBufferAction)
        icon_path = ':/plugins/kwg_geoenrichment/resources/icon_DrawT.png'
        self.add_action(
            icon_path,
            text=self.tr('Buffer drawing tool on the selected layer'),
            checkable=True,
            add_to_toolbar=True,
            menu=bufferMenu,
            callback=self.drawBuffer,
            parent=self.iface.mainWindow()
        )
        icon_path = ':/plugins/kwg_geoenrichment/resources/icon_Settings.png'
        self.add_action(
            icon_path,
            text=self.tr('Settings'),
            add_to_toolbar=True,
            callback=self.showSettingsWindow,
            parent=self.iface.mainWindow()
        )

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&KWG Geoenrichment'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
        self.dlg = kwg_geoenrichmentDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass


    def runPropertyEnrichment(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
        self.dlgPropertyEnrichment = kwg_property_geoenrichmentDialog()

        QgsMessageLog.logMessage("Retrieving common properties based on geometry selection", "kwg_geoenrichment",
                                 level=Qgis.Info)
        # show the dialog
        self.dlgPropertyEnrichment.show()

        kwgpropeenrichment = kwg_property_enrichment()

        # get common properties
        results = kwgpropeenrichment.getCommonProperties()
        self.updateParamsPropertyEnrichment(results)

        # get sosa obs properties
        results = kwgpropeenrichment.getsosaObsPropNameList()
        self.updateParamsPropertyEnrichment(results)

        QgsMessageLog.logMessage("Common properties retrieved successfully", "kwg_geoenrichment", level=Qgis.Info)

        # Run the dialog event loop
        result = self.dlgPropertyEnrichment.exec_()
        # See if OK was pressed
        if result:
            params = {}

            params["sparql_endpoint"] = self.dlgPropertyEnrichment.lineEdit.text()


            items = self.dlgPropertyEnrichment.listWidget.selectedItems()

            propertySelectList = []
            for item, val in enumerate(items):
                QgsMessageLog.logMessage( "selected: " + val.text(), "kwg_geoenrichment",
                                         level=Qgis.Info)
                propertySelectList.append(val.text())
            params["propertySelect"] = propertySelectList


            kwgpropeenrichment.execute(parameters=params, ifaceObj=self.iface)


    def runPropertyMerge(self):
        """KWG Property Merge tool"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
        self.dlgPropertyMerge = kwg_property_mergeDialog()

        QgsMessageLog.logMessage("KWG Property Merge tool", "kwg_geoenrichment",
                                 level=Qgis.Info)

        names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]

        # show the dialog
        self.dlgPropertyMerge.show()

        # Run the dialog event loop
        result = self.dlgPropertyMerge.exec_()
        # See if OK was pressed
        if result:
            params = self.getPropertyMergeparams()

            kwgpropmerge = kwg_property_merge()
            kwgpropmerge.execute(parameters=params)

        return


    def runRelationshipFinder(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
        self.dlgRelFinder = kwg_linkedDataDialog()

        relFinder = kwg_linkedData_relationship_finder()

        # show the dialog
        self.dlgRelFinder.show()
        # Run the dialog event loop
        result = self.dlgRelFinder.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            params = self.getParamsRelFinder()
            relFinder.execute(params, ifaceObj=self.iface)


    def runKWGExplore(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
        self.dlg = kwg_exploreDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlgRelFinder.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass



    def updateParamsPropertyEnrichment(self, propertiesDict):
        listWidget = self.dlgPropertyEnrichment.listWidget
        itemsTextList = [str(listWidget.item(i).text()) for i in range(listWidget.count())]

        for key in propertiesDict:
            if key not in itemsTextList:
                listWidget.addItem(key)
        listWidget.setSelectionMode(QAbstractItemView.ExtendedSelection)

        return


    def getParamsRelFinder(self):
        params = {}

        params["sparql_endpoint"] = self.dlgRelFinder.lineEdit.text()
        params["feat_class"] = self.dlgRelFinder.lineEdit_2.text()

        params["degree_val"] = self.dlgRelFinder.comboBox_degree.currentText()

        # get First Degree Property
        params["first_degree_property"] = self.dlgRelFinder.comboBox_1.currentText()
        # params["first_degree_property_direction"] = self.dlgRelFinder.comboBox_3.currentText()
        params["first_degree_property_direction"] = "BOTH"

        # get Second Degree Property
        params["second_degree_property"] = self.dlgRelFinder.comboBox_2.currentText()
        # params["second_degree_property_direction"] = self.dlgRelFinder.comboBox_5.currentText()
        params["second_degree_property_direction"] = "BOTH"

        # get Third Degree Property
        params["third_degree_property"] = self.dlgRelFinder.comboBox_3.currentText()
        # params["third_degree_property_direction"] = self.dlgRelFinder.comboBox_7.currentText()
        params["third_degree_property_direction"] = "BOTH"

        return params


    def getPropertyMergeparams(self):
        params = {}

        params["feature_class"] = self.dlgPropertyMerge.lineEdit.text()
        params["non_functional_property"] = self.dlgPropertyMerge.lineEdit_2.text()

        # TODO: set up displaying related tables logic
        # params["related_tables"] = self.dlgPropertyMerge.comboBox_2.currentText()

        params["merge_rule"] = self.dlgPropertyMerge.comboBox.currentText()

        # TODO: set up signal for listening inputs and handle the delim values
        params["concat_delimiter"] = ","

        return params


    def drawPoint(self):
        if self.tool:
            self.tool.reset()
        self.tool = DrawPoint(self.iface, self.settings.getColor())
        self.tool.setAction(self.actions[0])
        self.tool.selectionDone.connect(self.draw)
        self.iface.mapCanvas().setMapTool(self.tool)
        self.drawShape = 'point'
        self.toolname = 'drawPoint'
        self.resetSB()


    def drawXYPoint(self):
        tuple, ok = XYDialog().getPoint(
            self.iface.mapCanvas().mapSettings().destinationCrs())
        point = tuple[0]
        self.XYcrs = tuple[1]
        if ok:
            if point.x() == 0 and point.y() == 0:
                QMessageBox.critical(
                    self.iface.mainWindow(),
                    self.tr('Error'), self.tr('Invalid input !'))
            else:
                self.drawPoint()
                self.tool.rb = QgsRubberBand(
                    self.iface.mapCanvas(), QgsWkbTypes.PointGeometry)
                self.tool.rb.setColor(self.settings.getColor())
                self.tool.rb.setWidth(3)
                self.tool.rb.addPoint(point)
                self.drawShape = 'XYpoint'
                self.draw()


    def drawDMSPoint(self):
        point, ok = DMSDialog().getPoint()
        self.XYcrs = QgsCoordinateReferenceSystem(4326)
        if ok:
            if point.x() == 0 and point.y() == 0:
                QMessageBox.critical(
                    self.iface.mainWindow(),
                    self.tr('Error'), self.tr('Invalid input !'))
            else:
                self.drawPoint()
                self.tool.rb = QgsRubberBand(
                    self.iface.mapCanvas(), QgsWkbTypes.PointGeometry)
                self.tool.rb.setColor(self.settings.getColor())
                self.tool.rb.setWidth(3)
                self.tool.rb.addPoint(point)
                self.drawShape = 'XYpoint'
                self.draw()


    def drawLine(self):
        if self.tool:
            self.tool.reset()
        self.tool = DrawLine(self.iface, self.settings.getColor())
        self.tool.setAction(self.actions[1])
        self.tool.selectionDone.connect(self.draw)
        self.tool.move.connect(self.updateSB)
        self.iface.mapCanvas().setMapTool(self.tool)
        self.drawShape = 'line'
        self.toolname = 'drawLine'
        self.resetSB()

    # rectangle drawing procedure
    # def drawRect(self):
    #     if self.tool:
    #         self.tool.reset()
    #     self.tool = DrawRect(self.iface, self.settings.getColor())
    #     self.tool.setAction(self.actions[2])
    #     self.tool.selectionDone.connect(self.draw)
    #     self.tool.move.connect(self.updateSB)
    #     self.iface.mapCanvas().setMapTool(self.tool)
    #     self.drawShape = 'polygon'
    #     self.toolname = 'drawRect'
    #     self.resetSB()
    #

    # circle drawing procedure
    # def drawCircle(self):
    #     if self.tool:
    #         self.tool.reset()
    #     self.tool = DrawCircle(self.iface, self.settings.getColor(), 40)
    #     self.tool.setAction(self.actions[3])
    #     self.tool.selectionDone.connect(self.draw)
    #     self.tool.move.connect(self.updateSB)
    #     self.iface.mapCanvas().setMapTool(self.tool)
    #     self.drawShape = 'polygon'
    #     self.toolname = 'drawCircle'
    #     self.resetSB()

    def drawPolygon(self):
        if self.tool:
            self.tool.reset()
        self.tool = DrawPolygon(self.iface, self.settings.getColor())
        self.tool.setAction(self.actions[4])
        self.tool.selectionDone.connect(self.draw)
        self.tool.move.connect(self.updateSB)
        self.iface.mapCanvas().setMapTool(self.tool)
        self.drawShape = 'polygon'
        self.toolname = 'drawPolygon'
        self.resetSB()


    def drawBuffer(self):
        self.bGeom = None
        if self.tool:
            self.tool.reset()
        self.tool = SelectPoint(self.iface, self.settings.getColor())
        self.actions[5].setIcon(
            QIcon(':/plugins/kwg_geoenrichment/resources/icon_DrawT.png'))
        self.actions[5].setText(
            self.tr('Buffer drawing tool on the selected layer'))
        self.actions[5].triggered.disconnect()
        self.actions[5].triggered.connect(self.drawBuffer)
        self.actions[5].menu().actions()[0].setIcon(
            QIcon(':/plugins/kwg_geoenrichment/resources/icon_DrawTP.png'))
        self.actions[5].menu().actions()[0].setText(
            self.tr('Polygon buffer drawing tool on the selected layer'))
        self.actions[5].menu().actions()[0].triggered.disconnect()
        self.actions[5].menu().actions()[0].triggered.connect(
            self.drawPolygonBuffer)
        self.tool.setAction(self.actions[5])
        self.tool.select.connect(self.selectBuffer)
        self.tool.selectionDone.connect(self.draw)
        self.iface.mapCanvas().setMapTool(self.tool)
        self.drawShape = 'polygon'
        self.toolname = 'drawBuffer'
        self.resetSB()


    def drawPolygonBuffer(self):
        self.bGeom = None
        if self.tool:
            self.tool.reset()
        self.tool = DrawPolygon(self.iface, self.settings.getColor())
        self.actions[5].setIcon(
            QIcon(':/plugins/kwg_geoenrichment/resources/icon_DrawTP.png'))
        self.actions[5].setText(
            self.tr('Polygon buffer drawing tool on the selected layer'))
        self.actions[5].triggered.disconnect()
        self.actions[5].triggered.connect(self.drawPolygonBuffer)
        self.actions[5].menu().actions()[0].setIcon(
            QIcon(':/plugins/kwg_geoenrichment/resources/icon_DrawT.png'))
        self.actions[5].menu().actions()[0].setText(
            self.tr('Buffer drawing tool on the selected layer'))
        self.actions[5].menu().actions()[0].triggered.disconnect()
        self.actions[5].menu().actions()[0].triggered.connect(self.drawBuffer)
        self.tool.setAction(self.actions[5])
        self.tool.selectionDone.connect(self.selectBuffer)
        self.iface.mapCanvas().setMapTool(self.tool)
        self.drawShape = 'polygon'
        self.toolname = 'drawBuffer'
        self.resetSB()


    def showSettingsWindow(self):
        self.settings.settingsChanged.connect(self.settingsChangedSlot)
        self.settings.show()


    # triggered when a setting is changed
    def settingsChangedSlot(self):
        if self.tool:
            self.tool.rb.setColor(self.settings.getColor())


    def resetSB(self):
        message = {
            'drawPoint': 'Left click to place a point.',
            'drawLine': 'Left click to place points. Right click to confirm.',
            'drawRect': 'Maintain the left click to draw a rectangle.',
            'drawCircle': 'Maintain the left click to draw a circle. \
Simple Left click to give a perimeter.',
            'drawPolygon': 'Left click to place points. Right click to \
confirm.',
            'drawBuffer': 'Select a vector layer in the Layer Tree, \
then select an entity on the map.'
        }
        self.sb.showMessage(self.tr(message[self.toolname]))


    def updateSB(self):
        g = self.geomTransform(
            self.tool.rb.asGeometry(),
            self.iface.mapCanvas().mapSettings().destinationCrs(),
            QgsCoordinateReferenceSystem.fromEpsgId(2154))
        if self.toolname == 'drawLine':
            if g.length() >= 0:
                self.sb.showMessage(
                    self.tr('Length') + ': ' + str("%.2f" % g.length()) + " m")
            else:
                self.sb.showMessage(self.tr('Length')+': '+"0 m")
        else:
            if g.area() >= 0:
                self.sb.showMessage(
                    self.tr('Area')+': '+str("%.2f" % g.area())+" m"+u'²')
            else:
                self.sb.showMessage(self.tr('Area')+': '+"0 m"+u'²')
        self.iface.mapCanvas().mapSettings().destinationCrs().authid()


    def geomTransform(self, geom, crs_orig, crs_dest):
        g = QgsGeometry(geom)
        crsTransform = QgsCoordinateTransform(
            crs_orig, crs_dest, QgsCoordinateTransformContext())  # which context ?
        g.transform(crsTransform)
        return g


    def selectBuffer(self):
        rb = self.tool.rb
        if isinstance(self.tool, DrawPolygon):
            rbSelect = self.tool.rb
        else:
            rbSelect = self.tool.rbSelect
        layer = self.iface.layerTreeView().currentLayer()
        if layer is not None and layer.type() == QgsMapLayer.VectorLayer \
                and self.iface.layerTreeView().currentNode().isVisible():
            # rubberband reprojection
            g = self.geomTransform(
                rbSelect.asGeometry(),
                self.iface.mapCanvas().mapSettings().destinationCrs(),
                layer.crs())
            features = layer.getFeatures(QgsFeatureRequest(g.boundingBox()))
            rbGeom = []
            for feature in features:
                geom = feature.geometry()
                try:
                    if g.intersects(geom):
                        rbGeom.append(feature.geometry())
                except:
                    # there's an error but it intersects
                    # fix_print_with_import
                    print('error with '+layer.name()+' on '+str(feature.id()))
                    rbGeom.append(feature.geometry())
            if len(rbGeom) > 0:
                for geometry in rbGeom:
                    if rbGeom[0].combine(geometry) is not None:
                        if self.bGeom is None:
                            self.bGeom = geometry
                        else:
                            self.bGeom = self.bGeom.combine(geometry)
                rb.setToGeometry(self.bGeom, layer)
        if isinstance(self.tool, DrawPolygon):
            self.draw()


    def draw(self):
        rb = self.tool.rb
        g = rb.asGeometry()

        ok = True
        warning = False
        errBuffer_noAtt = False
        errBuffer_Vertices = False

        layer = self.iface.layerTreeView().currentLayer()
        if self.toolname == 'drawBuffer':
            if self.bGeom is None:
                warning = True
                errBuffer_noAtt = True
            else:
                perim, ok = QInputDialog.getDouble(
                    self.iface.mainWindow(), self.tr('Perimeter'),
                    self.tr('Give a perimeter in m:')
                    + '\n'+self.tr('(works only with metric crs)'),
                    min=0)
                g = self.bGeom.buffer(perim, 40)
                rb.setToGeometry(g, QgsVectorLayer(
                    "Polygon?crs="+layer.crs().authid(), "", "memory"))
                if g.length() == 0 and ok:
                    warning = True
                    errBuffer_Vertices = True

        if self.toolname == 'drawCopies':
            if g.length() < 0:
                warning = True
                errBuffer_noAtt = True

        if ok and not warning:

            name = "geo_enrichment_polygon"

            # save the buffer
            if self.drawShape == 'point':
                layer = QgsVectorLayer(
                    "Point?crs=" + self.iface.mapCanvas().mapSettings().destinationCrs().authid() + "&field=" + self.tr(
                        'Geometry') + ":string(255)", name, "memory")
                g = g.centroid()  # force geometry as point
            elif self.drawShape == 'XYpoint':
                layer = QgsVectorLayer(
                    "Point?crs=" + self.XYcrs.authid() + "&field=" + self.tr('Geometry') + ":string(255)", name,
                    "memory")
                g = g.centroid()
            elif self.drawShape == 'line':
                layer = QgsVectorLayer(
                    "LineString?crs=" + self.iface.mapCanvas().mapSettings().destinationCrs().authid() + "&field=" + self.tr(
                        'Geometry') + ":string(255)", name, "memory")
                # fix_print_with_import
                print(
                    "LineString?crs=" + self.iface.mapCanvas().mapSettings().destinationCrs().authid() + "&field=" + self.tr(
                        'Geometry') + ":string(255)")
            else:
                layer = QgsVectorLayer(
                    "Polygon?crs=" + self.iface.mapCanvas().mapSettings().destinationCrs().authid() + "&field=" + self.tr(
                        'Geometry') + ":string(255)", name, "memory")

            layer.startEditing()
            symbols = layer.renderer().symbols(QgsRenderContext())  # todo which context ?
            symbols[0].setColor(self.settings.getColor())
            feature = QgsFeature()
            feature.setGeometry(g)
            feature.setAttributes([name])
            layer.dataProvider().addFeatures([feature])
            layer.commitChanges()

            pjt = QgsProject.instance()
            pjt.addMapLayer(layer, False)
            if pjt.layerTreeRoot().findGroup(self.tr('Geometry')) is None:
                pjt.layerTreeRoot().insertChildNode(
                    0, QgsLayerTreeGroup(self.tr('Geometry')))
            group = pjt.layerTreeRoot().findGroup(
                self.tr('Geometry'))
            group.insertLayer(0, layer)
            self.iface.layerTreeView().refreshLayerSymbology(layer.id())
            self.iface.mapCanvas().refresh()
            QgsMessageLog.logMessage("Your polygon has been saved to a layer", "kwg_geoenrichment", level=Qgis.Info)

            self.dlg = kwg_geoenrichmentDialog()

            self.populateEventPlaceTypes()

            # show the dialog
            self.dlg.show()
            # Run the dialog event loop
            result = self.dlg.exec_()
            # See if OK was pressed
            if result:
                params = self.getInputs()

                QgsMessageLog.logMessage("Contacting the server with the geoSPARQL request", "kwg_geoenrichment",
                                         level=Qgis.Info)

                wkt_literal = self.performWKTConversion()
                self.logger.debug(wkt_literal)
                geoSPARQLResponse = self.sparqlQuery.TypeAndGeoSPARQLQuery(query_geo_wkt=wkt_literal, selectedURL=params["place_type"], geosparql_func=params["geosparql_func"])

                # self.logger.debug(json.dumps(geoSPARQLResponse))
                QgsMessageLog.logMessage("GeoJSON response received from the server", "kwg_geoenrichment",
                                         level=Qgis.Info)
                self.handleGeoJSONObject(geoResult=geoSPARQLResponse)
                pass

        self.tool.reset()
        self.resetSB()
        self.bGeom = None


    def populateEventPlaceTypes(self):
        sparqlResultJSON = self.sparqlQuery.EventTypeSPARQLQuery()
        QgsMessageLog.logMessage(json.dumps(sparqlResultJSON), "kwg_geoenrichment",
                                 level=Qgis.Info)
        for obj in sparqlResultJSON:
            if((obj["entityType"] is not None and obj["entityType"]["type"] is not None and obj["entityType"]["type"] == "uri" ) and
                    (obj["entityTypeLabel"] is not None and obj["entityTypeLabel"]["type"] is not None and obj["entityTypeLabel"]["type"] == "literal" )):
                self.eventPlaceTypeDict[obj["entityTypeLabel"]["value"]] = obj["entityType"]["value"]

        for key in self.eventPlaceTypeDict:
            self.dlg.comboBox.addItem(key)

        return


    def getInputs(self):
        params = {}
        params["end_point"] = self.dlg.lineEdit.text()
        params["place_type"] = self.eventPlaceTypeDict[self.dlg.comboBox.currentText()]  if (self.dlg.comboBox.currentText() in self.eventPlaceTypeDict) else self.dlg.comboBox.currentText()
        params["relation_type"] = self.dlg.comboBox_2.currentText()
        params["is_direct_instance"] = self.dlg.checkBox.isChecked()

        # get the function
        geosparql_func = list()
        if params["relation_type"] == "Contain + Intersect":
            geosparql_func = ["geo:sfContains", "geo:sfIntersects"]
        elif params["relation_type"] == "Contain":
            geosparql_func = ["geo:sfContains"]
        elif params["relation_type"] == "Within":
            geosparql_func = ["geo:sfWithin"]
        elif params["relation_type"] == "Intersect":
            geosparql_func = ["geo:sfIntersects"]
        else:
            QgsMessageLog.logMessage("The spatial relation is not supported!", "kwg_geoenrichment", level=Qgis.Critical)

        params["geosparql_func"] = geosparql_func

        return params


    def performWKTConversion(self):
        layers = QgsProject.instance().mapLayers().values()
        QgsMessageLog.logMessage("Reading all the layers", "kwg_geoenrichment", level=Qgis.Info)

        # crs = QgsCoordinateReferenceSystem("EPSG:4326")
        for layer in layers:
            # self.logger.debug(layer.name())
            if layer.name() == "geo_enrichment_polygon":
                QgsMessageLog.logMessage("Retrieving features from the geoenrichment layer", "kwg_geoenrichment", level=Qgis.Info)
                feat = layer.getFeatures()
                for f in feat:
                    geom = f.geometry()

                    # TODO: handle the CRS
                    # geom = self.transformSourceCRStoDestinationCRS(geom)

                    QgsMessageLog.logMessage("Geometry found", "kwg_geoenrichment", level=Qgis.Info)
                    wkt = geom.asWkt()
                break

        wkt_literal_list = wkt.split(" ", 1)
        wkt_rep = ""
        wkt_rep = wkt_literal_list[0].upper() + wkt_literal_list[1]

        QgsMessageLog.logMessage("wkt representation :  " + wkt_rep , "kwg_geoenrichment", level=Qgis.Info)

        return wkt_rep


    def handleGeoJSONObject(self, geoResult):
        QgsMessageLog.logMessage("handleGeoJSONObject", "kwg_geoenrichment", level=Qgis.Info)

        with open('/var/local/QGIS/kwg_data.geojson', 'w') as f:
            geojson.dump(geoResult, f)

        geopackagedResponse = self.createGeoPackageFromSPARQLResult(geoResult)
        # self.createShapeFileFromSPARQLResult(geoResult)

        if (geopackagedResponse):
            QgsMessageLog.logMessage("Successfully created a geopackage file", "kwg_geoenrichment", level=Qgis.Info)
        else:
            QgsMessageLog.logMessage("Error while writing geopackage", "kwg_geoenrichment", level=Qgis.Error)

        pass


    def createShapeFileFromSPARQLResult(self, GeoQueryResult, out_path="/var/local/QGIS/kwg_results.shp", inPlaceType="", selectedURL="",
                                           isDirectInstance=False):
        '''
        GeoQueryResult: a sparql query result json obj serialized as a list of dict()
                    SPARQL query like this:
                    select distinct ?place ?placeLabel ?placeFlatType ?wkt
                    where
                    {...}
        out_path: the output path for the create geo feature class
        inPlaceType: the label of user spercified type IRI
        selectedURL: the user spercified type IRI
        isDirectInstance: True: use placeFlatType as the type of geo-entity
                          False: use selectedURL as the type of geo-entity
        '''
        # a set of unique WKT for each found places
        placeIRISet = set()
        placeList = []
        geom_type = None

        layerFields = QgsFields()
        layerFields.append(QgsField('place_iri', QVariant.String))
        layerFields.append(QgsField('label', QVariant.String))
        layerFields.append(QgsField('type_iri', QVariant.String))

        writer = QgsVectorFileWriter(out_path, 'UTF-8', layerFields, QgsWkbTypes.Polygon,
                                     QgsCoordinateReferenceSystem('EPSG:4326'), 'ESRI Shapefile')

        for idx, item in enumerate(GeoQueryResult):
            wkt_literal = item["wkt"]["value"]
            # for now, make sure all geom has the same geometry type
            if idx == 0:
                geom_type = UTIL.get_geometry_type_from_wkt(wkt_literal)
            else:
                assert geom_type == UTIL.get_geometry_type_from_wkt(wkt_literal)

            if isDirectInstance == False:
                placeType = item["placeFlatType"]["value"]
            else:
                placeType = selectedURL
            print("{}\t{}\t{}".format(
                item["place"]["value"], item["placeLabel"]["value"], placeType))
            if len(placeIRISet) == 0 or item["place"]["value"] not in placeIRISet:
                placeIRISet.add(item["place"]["value"])
                placeList.append(
                    [item["place"]["value"], item["placeLabel"]["value"], placeType, wkt_literal])

        if geom_type is None:
            raise Exception("geometry type not find")

        if len(placeList) == 0:
            QgsMessageLog.logMessage("No {0} within the provided polygon can be finded!".format(inPlaceType), level=Qgis.Info)
        else:

            if out_path == None:
                QgsMessageLog.logMessage("No data will be added to the map document.", level=Qgis.Info)
            else:


                # labelFieldLength = Json2Field.fieldLengthDecide(GeoQueryResult, "placeLabel")
                #
                # urlFieldLength = Json2Field.fieldLengthDecide(GeoQueryResult, "place")
                #
                # if isDirectInstance == False:
                #     classFieldLength = Json2Field.fieldLengthDecide(GeoQueryResult, "placeFlatType")
                # else:
                #     classFieldLength = len(selectedURL) + 50

                for item in placeList:
                    place_iri, label, type_iri, wkt_literal = item
                    wkt = wkt_literal.replace("<http://www.opengis.net/def/crs/OGC/1.3/CRS84>", "")

                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromWkt(wkt))
                    feat.setAttributes(item[0:3])

                    writer.addFeature(feat)

                self.iface.addVectorLayer(out_path, 'kwg_results', 'ogr')

        del(writer)

        return



    def createGeoPackageFromSPARQLResult(self, GeoQueryResult, out_path="/var/local/QGIS/kwg_results.gpkg", inPlaceType="", selectedURL="",
                                           isDirectInstance=False):
        '''
        GeoQueryResult: a sparql query result json obj serialized as a list of dict()
                    SPARQL query like this:
                    select distinct ?place ?placeLabel ?placeFlatType ?wkt
                    where
                    {...}
        out_path: the output path for the create geo feature class
        inPlaceType: the label of user spercified type IRI
        selectedURL: the user spercified type IRI
        isDirectInstance: True: use placeFlatType as the type of geo-entity
                          False: use selectedURL as the type of geo-entity
        '''
        # a set of unique WKT for each found places
        placeIRISet = set()
        placeList = []
        geom_type = None

        util_obj = UTIL()

        layerFields = QgsFields()
        layerFields.append(QgsField('place_iri', QVariant.String))
        layerFields.append(QgsField('label', QVariant.String))
        layerFields.append(QgsField('type_iri', QVariant.String))

        for idx, item in enumerate(GeoQueryResult):
            wkt_literal = item["wkt"]["value"]
            # for now, make sure all geom has the same geometry type
            if idx == 0:
                geom_type = util_obj.get_geometry_type_from_wkt(wkt_literal)
            else:
                assert geom_type == util_obj.get_geometry_type_from_wkt(wkt_literal)

            if isDirectInstance == False:
                placeType = item["placeFlatType"]["value"]
            else:
                placeType = selectedURL
            print("{}\t{}\t{}".format(
                item["place"]["value"], item["placeLabel"]["value"], placeType))
            if len(placeIRISet) == 0 or item["place"]["value"] not in placeIRISet:
                placeIRISet.add(item["place"]["value"])
                placeList.append(
                    [item["place"]["value"], item["placeLabel"]["value"], placeType, wkt_literal])

        if geom_type is None:
            raise Exception("geometry type not find")

        vl = QgsVectorLayer(geom_type+"?crs=epsg:4326", "geo_results", "memory")
        pr = vl.dataProvider()
        pr.addAttributes(layerFields)
        vl.updateFields()

        if len(placeList) == 0:
            QgsMessageLog.logMessage("No {0} within the provided polygon can be finded!".format(inPlaceType), level=Qgis.Info)
        else:

            if out_path == None:
                QgsMessageLog.logMessage("No data will be added to the map document.", level=Qgis.Info)
            else:

                for item in placeList:
                    place_iri, label, type_iri, wkt_literal = item
                    wkt = wkt_literal.replace("<http://www.opengis.net/def/crs/OGC/1.3/CRS84>", "")

                    feat = QgsFeature()
                    geom = QgsGeometry.fromWkt(wkt)

                    # TODO: handle the CRS
                    # feat.setGeometry(self.transformSourceCRStoDestinationCRS(geom, src=4326, dest=3857))

                    feat.setGeometry(geom)
                    feat.setAttributes(item[0:3])

                    pr.addFeature(feat)
                vl.updateExtents()

                options = QgsVectorFileWriter.SaveVectorOptions()
                options.layerName = 'geo_results'
                context = QgsProject.instance().transformContext()
                error = QgsVectorFileWriter.writeAsVectorFormatV2(vl, out_path, context, options)
                self.iface.addVectorLayer(out_path, 'geo_results', 'ogr')

        return error[0] == QgsVectorFileWriter.NoError


    def transformSourceCRStoDestinationCRS(self, geom, src=3857, dest=4326):
        src_crs = QgsCoordinateReferenceSystem(src)
        dest_crs = QgsCoordinateReferenceSystem(dest)
        geom_converter = QgsCoordinateTransform(src_crs, dest_crs, QgsProject.instance())
        geom_reproj = geom_converter.transform(geom)
        return geom_reproj
